---
title: "Exercises1-4"
format: html
editor: visual
---

```{r}
#load packages
library(ggplot2)
library(tibble)
```

## Getting Started Exercises

```{r}
#show mpg data table
mpg
```

Try it yourself! Using nothing other than ggplot2 and the `mpg` data set, create your own artwork. Don't take too long: 3 minutes at the absolute most! See what you can come up with in that time!

```{r}
#using mpg datafram, create ggplot with customized point sizes and colors, map the coordinates, create void theme, and use a continuous set of colors throughout points
mpg |>
  ggplot(aes(displ, cty, colour = drv)) + 
  geom_point(show.legend = FALSE, size = 3) + 
  geom_point(show.legend = FALSE, size = 1, colour = "coral") + 
  coord_polar() + 
  theme_void() + 
  scale_color_brewer()
```

1.  In the materials folder there is a file called `polar_art.R` that contains a copy of the `polar_art()` function. Open it and use the `polar_art()` function to generate your own pieces. Try changing the `seed`, `n`, and the `palette` to create a variety of different pieces.

```{r}
polar_art <- function(seed, n, palette) {
  
  #setting state for random number generator
  set.seed(seed)
  
  #making new data frame containing random values for 
  #aesthetics we might want to use in the art
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + runif(n, min = -.7, max = .7),
    y1 = y0 + runif(n, min = -.7, max = .7),
    shade = runif(n), 
    size = runif(n)
  )
  
  # plot segments in various colours, using 
  # polar coordinates and a gradient palette
  dat |> 
    ggplot(aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = size
    )) +
    geom_segment(show.legend = FALSE) +
    coord_polar() +
    scale_y_continuous(expand = c(0, 0)) +
    scale_x_continuous(expand = c(0, 0)) + 
    scale_colour_gradientn(colours = palette) + 
    scale_size(range = c(0, 3)) + 
    theme_void()
}
#set your own colors
polar_art(seed = 1, n = 300, palette = c("coral", "red", "orange"))
polar_art(seed = 1, n = 150, palette = c("green", "purple", "black"))
polar_art(seed = 3, n = 1000, palette = c("yellow", "pink", "seagreen"))
```

3.  Create a new file called `polar_art_02.R` that contains the `polar_art()` function. In the new file, try modifying the `polar_art()` function itself to see if you can create your own new system.

    included with file!

4.  Something to think about: Usually in data science we try to avoid naming our files `my_file_version_1`, `my_file_version_2`, etc, and instead we place files under version control using git. Yet here I am in an art context, apparently giving the advice to fall back on the old-fashioned system of naming files with version numbers. Why might I be doing that?

You may be doing it to show different versions when creating new files, to delineate the original file from the newer versions

## Colour

```{r}
#load packages
library(scales)
library(ggthemes)
```

```{r}
#create object of colors
pal <- c("#528B8B", "#00BFFF", "#1874CD", "#66CDAA", "#E066FF")

#show colors 
show_col(pal)

#construct continuous color scale
palette_fn <- colorRampPalette(pal)

#construct color spectrum
palette_fn(100)

#smooth palette
image(
  x = matrix(1:100, ncol = 1), 
  col = palette_fn(100),
  useRaster = TRUE,
  axes = FALSE
)

#palette from canva
canva_palettes[[80]]

#show color palette
show_col(canva_palettes[[70]])
```

1.  In the materials folder there is a file called `palette-generators.R` that contains a copy of the `sample_canva()` function. Take a look and try calling the function a few times to see what kind of output it produces. You may find it handy to use `show_col()` to visualise the results.

    ```{r}
    # the original function from the first session
    sample_canva <- function(seed = NULL) {
      if(!is.null(seed)) set.seed(seed)
      sample(ggthemes::canva_palettes, 1)[[1]]
    }

    # the extended function used in later sessions
    sample_canva2 <- function(seed = NULL, n = 4) {
      if(!is.null(seed)) set.seed(seed)
      sample(ggthemes::canva_palettes, 1)[[1]] |>
        (\(x) colorRampPalette(x)(n))()  
    }

    #visualize colors in the palette
    show_col(canva_palettes[[1]])
    ```

<!-- -->

1.  Try writing your own random palette generator. A simple (and occasionally useful) approach is to construct a palette consisting of distinct but otherwise randomly selected named colours in R. There is a set of 502 colour names generated by calling `colours()` with `distinct = TRUE)`. Write a function called `sample_named_colours()` that takes `n` as an input argument, and then returns a sample of `n` of these colour. Try using it with the `polar_art()` function.

```{r}
#load package
library(ggthemes)

#write a function naming it sample named colors with n inputs and samples from the palette loaded. 502 colours are generated by calling colors in the sampling function
sample_named_colours <- function(seed, n = 6, palette) {
  set.seed(seed)
  sample(colours(distinct = F))
}

#make seed null, with n=6 samples
sample_named_colours(seed = NULL, n = 6, palette = colours) %>% 
  show_col()
```

1.  The `sample_canva()` function, as I've written it, preserves the original structure of the 150 palettes in `ggthemes::canva_palettes`, so that the 4 colours returned all belong to the same palette on the Canva website originally. Try breaking this constraint. If you call `unlist(ggthemes::canva_palettes)` you get a vector of 600 distinct colours. Write a palette generating function that samples colours randomly from that set of 600 colours.

```{r}
#breaking constraint for 150 palettes in canva palet. 
random__palette <- function(seed) {
  #create vector or 6 distinct colors
  canva_colors <- unlist(ggthemes::canva_palettes)
  #sample colors randomly
  sample_colours <- sample(canva_colors, seed)

  sample_colours
  show_col()}
```

## Composition

```{r}
library(dplyr)
```

```{r}
sample_canva <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]]
}

sample_data <- function(seed = NULL, n = 100){
  if(!is.null(seed)) set.seed(seed)
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + runif(n, min = -.2, max = .2),
    y1 = y0 + runif(n, min = -.2, max = .2),
    shade = runif(n), 
    size = runif(n),
    shape = factor(sample(0:22, size = n, replace = TRUE))
)
}

polar_styled_plot <- function(data = NULL, palette) 
  ggplot(
    data = data,
    mapping = aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = size
    )) + 
    coord_polar(clip = "off") +
    scale_y_continuous(
      expand = c(0, 0),
      limits = c(0, 1), 
      oob = scales::oob_keep
    ) +
    scale_x_continuous(
      expand = c(0, 0), 
      limits = c(0, 1), 
      oob = scales::oob_keep
    ) + 
    scale_colour_gradientn(colours = palette) + 
    scale_size(range = c(0, 10)) + 
    theme_void() + 
    guides(
      colour = guide_none(),
      size = guide_none(),
      fill = guide_none(),
      shape = guide_none()
    )
   data1 <- sample_data(n = 150, seed = 1) 
   pal1 <- sample_canva(seed = 2)


polar_styled_plot(data = data1, palette = pal1) + geom_segment()
polar_styled_plot(data = data1, palette = pal1) + geom_path()
polar_styled_plot(data = data1, palette = pal1) + geom_point()
```

1.  In the materials folder there is a file called `polar-styled-plots.R` that contains a copy of the `sample_canva()`, `sample_data()` and `polar_styled_plot()` functions. Without modifying any of these three functions, explore how much flexibility you have to make different pieces in which (1) data are generated with `sample_data()`, (2) the plot is initialised by calling `polar_styled_plot()`, and (3) the piece is created by adding ggplot2 geoms. Data manipulation with dplyr is allowed!

```{r}
{
dat1 <- sample_data(n = 1500, seed = 143) 
dat2 <- sample_data(n = 100, seed = 357) |>  
  mutate(y0 = .3 + y0 * .6, y1 = .3)

polar_styled_plot(palette = sample_canva(seed = 9)) + 
  geom_segment(
    data = dat1 |> mutate(size = size * 4)
  ) + 
  geom_segment(
    data = dat2 |> mutate(size = size / 3), 
    lineend = "round", 
    colour = "white"
  ) +
  geom_segment(
    data = dat2 |> mutate(size = size / 6), 
    lineend = "round", 
    colour = "#EE7AE9"
  ) +
  geom_point(
    data = dat2 |> mutate(size = size * 4),
    colour = "#98FB98"
  )
}
```

1.  In the examples above and the previous exercise you saw that the `polar_styled_plot()` function plays the role of defining an overarching "style" for possible art pieces, but it doesn't completely constrain artistic freedom. Your task in this exercise is to try to write a `my_styled_plot()` that does something similar... but creates a different style that you can explore

```{r}
dat <- sample_data(n = 120, seed = 80) |>
  mutate(y1 = y0, size = size / 2)

polar_styled_plot(palette = sample_canva(seed = 600)) + 
  geom_segment(data = dat) + 
  geom_segment(data = dat |> mutate(y1 = y1 - .3, y0 = y0 - .5)) +
  geom_segment(data = dat |> mutate(y1 = y1 - .3, y0 = y0 - .2))
```

```{r}
dat2 <- sample_data(n = 200, seed = 1) |>
  mutate(y1 = y0, size = size / 2)

polar_styled_plot(palette = sample_canva(seed = 3)) + 
  geom_segment(data = dat, linetype = "331312") 
```

## Polygon Tricks

Code before exercises below packages

```{r}
library(dplyr)
library(purrr)
library(tidyr)
library(tibble)
library(ggplot2)
library(ambient)
library(tictoc)
library(ggthemes)
library(gifski)
library
```

```{r}
#specify coordinates for square 
square <- tibble(
  x = c(0, 1, 1, 0, 0),
  y = c(0, 0, 1, 1, 0),
  seg_len = c(1, 1, 1, 1, 0)
)
```

```{r}
#create square using plotting function
show_polygon <- function(polygon, show_vertices = TRUE, ...) {
  
  pic <- ggplot(polygon, aes(x, y)) +
    geom_polygon(colour = "black", fill = NA, show.legend = FALSE, ...) + 
    coord_equal() + 
    theme_void()
  
  if(show_vertices == TRUE) {
    pic <- pic + geom_point(colour = "black", size = .5)
  }
  return(pic) }

show_polygon(square) 
```

```{r}
#select edge to break into two
sample_edge <- function(polygon) {
  sample(nrow(polygon), 1, prob = polygon$seg_len)
}

```

```{r}
#compute edges length
edge_length <- function(x1, y1, x2, y2) {
  sqrt((x1 - x2)^2 + (y1 - y2)^2)
}
```

```{r}
#wrap around runif to make code easier to read and make sense of number generator
edge_noise <- function(size) {
  runif(1, min = -size/2, max = size/2)
}
```

```{r}
#selects edge and breaks into two edges. uses polygon as input and takes the noise argument to scale the noise
insert_edge <- function(polygon, noise) {
  
  # sample and edge and remember its length
  ind <- sample_edge(polygon)
  len <- polygon$seg_len[ind]
  
  # one endpoint of the old edge
  last_x <- polygon$x[ind]
  last_y <- polygon$y[ind]
  
  # the other endpoint of the old edge
  next_x <- polygon$x[ind + 1]
  next_y <- polygon$y[ind + 1]
  
  # location of the new point to be inserted: noise 
  # is scaled proportional to the length of the old edge
  new_x <- (last_x + next_x) / 2 + edge_noise(len * noise)
  new_y <- (last_y + next_y) / 2 + edge_noise(len * noise)
  
  # the new row for insertion into the tibble, 
  # containing coords and length of the 'new' edge
  new_row <- tibble(
    x = new_x,
    y = new_y,
    seg_len = edge_length(new_x, new_y, next_x, next_y)
  )
  
  # update the length of the 'old' edge
  polygon$seg_len[ind] <- edge_length(
    last_x, last_y, new_x, new_y
  )
  
  # insert a row into the tibble
  bind_rows(
    polygon[1:ind, ],
    new_row,
    polygon[-(1:ind), ]
  )
}

```

```{r}
#putting the function into play
set.seed(2)
polygon <- square 
polygon <- insert_edge(polygon, noise = .6); show_polygon(polygon)
polygon <- insert_edge(polygon, noise = .4); show_polygon(polygon)
polygon <- insert_edge(polygon, noise = .2); show_polygon(polygon)


```

```{r}
#inserts edges into polygon for fixed number of iterations at specific noise level. user can specify seed level (changed by me)

grow_polygon <- function(polygon, iterations, noise, seed = 6) {
  if(!is.null(seed)) set.seed(seed)
  for(i in 3:iterations) polygon <- insert_edge(polygon, noise)
  return(polygon)
}

```

```{r}
#show what polygon looks like after deformed iterations
square |> 
  grow_polygon(iterations = 50, noise = .8, seed = 4) |> 
  show_polygon(show_vertices = FALSE)
square |> 
  grow_polygon(iterations = 150, noise = .9, seed = 3) |> 
  show_polygon(show_vertices = FALSE)
square |> 
  grow_polygon(iterations = 300, noise = .7, seed = 5) |> 
  show_polygon(show_vertices = FALSE)

```

1.  The `grow-multipolygons.R` file contains the extra machinery to create these textured plots. Try playing around with the code for this. I've tweaked the parameter settings so that it runs faster than the code shown here, but doesn't produce output that looks quite as nice.

```{r}
#generalize polygons by creating many deformed polygons and calling the grow function repeatedly. plot polygons with low opacity

grow_multipolygon <- function(base_shape, n, seed = NULL, ...) {
  if(!is.null(seed)) set.seed(seed)
  polygons <- list()
  for(i in 1:n) {
    polygons[[i]] <- grow_polygon(base_shape, ...)
  }
  polygons <- bind_rows(polygons, .id = "id")
  polygons
}

show_multipolygon <- function(polygon, fill, alpha = .02, ...) {
  ggplot(polygon, aes(x, y, group = id)) +
    geom_polygon(colour = NA, alpha = alpha, fill = fill, ...) + 
    coord_equal() + 
    theme_void() }

```

```{r}
#deform original square moderately, grow polygon a set of iteration, create many polygons from base shape and then plot all. create graded look

tic()
dat <- square |> 
  grow_polygon(iterations = 200, noise = .6, seed = 2) |>
  grow_multipolygon(n = 60, iterations = 400, noise = 2, seed = 4)
toc()

#show dat
show_multipolygon(dat, fill = "#40E0D0")
```

1.  Let's look at single polygons. All the code you need to work with those is included in the `grow-polygon.R` function. Try modifying the `iterations`, `noise`, and `seed` arguments to see what kind of output is created at different parameter values.

```{r}
square <- tibble(
  x = c(0, 1, 1, 0, 0),
  y = c(0, 0, 1, 1, 0),
  seg_len = c(1, 1, 1, 1, 0)
)

show_polygon <- function(polygon, show_vertices = TRUE, colour = "black", ...) {
  
  pic <- ggplot(polygon, aes(x, y)) +
    geom_polygon(fill = NA, colour = colour, show.legend = FALSE, ...) + 
    coord_equal() + 
    theme_void()
  
  if(show_vertices == TRUE) {
    pic <- pic + geom_point(size = 2, colour = colour)
  }
  return(pic)
}

sample_edge <- function(polygon) {
  sample(nrow(polygon), 1, prob = polygon$seg_len)
}

edge_length <- function(x1, y1, x2, y2) {
  sqrt((x1 - x2)^2 + (y1 - y2)^2)
}

edge_noise <- function(size) {
  runif(1, min = -size/2, max = size/2)
}

insert_edge <- function(polygon, noise) {
  
  # sample and edge and remember its length
  ind <- sample_edge(polygon)
  len <- polygon$seg_len[ind]
  
  # one endpoint of the old edge
  last_x <- polygon$x[ind]
  last_y <- polygon$y[ind]
  
  # the other endpoint of the old edge
  next_x <- polygon$x[ind + 1]
  next_y <- polygon$y[ind + 1]
  
  # location of the new point to be inserted: noise 
  # is scaled proportional to the length of the old edge
  new_x <- (last_x + next_x) / 2 + edge_noise(len * noise)
  new_y <- (last_y + next_y) / 2 + edge_noise(len * noise)
  
  # the new row for insertion into the tibble, 
  # containing coords and length of the 'new' edge
  new_row <- tibble(
    x = new_x,
    y = new_y,
    seg_len = edge_length(new_x, new_y, next_x, next_y)
  )
  
  # update the length of the 'old' edge
  polygon$seg_len[ind] <- edge_length(
    last_x, last_y, new_x, new_y
  )
  
  # insert a row into the tibble
  bind_rows(
    polygon[1:ind, ],
    new_row,
    polygon[-(1:ind), ]
  )
}

grow_polygon <- function(polygon, iterations, noise, seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  for(i in 1:iterations) polygon <- insert_edge(polygon, noise)
  return(polygon)
}


# modify this code

#first modification
pic <- square |> 
  grow_polygon(iterations = 500, noise = .7, seed = 4) |> 
  show_polygon(show_vertices = FALSE)

plot(pic)
```

```{r}
#second modification
pic <- square |> 
  grow_polygon(iterations = 200, noise = .1, seed = 8) |> 
  show_polygon(show_vertices = FALSE)

plot(pic)

```

```{r}
#third modification
pic <- square |> 
  grow_polygon(iterations = 10000, noise = .4, seed = 5) |> 
  show_polygon(show_vertices = FALSE)

plot(pic)

```

## Growing Polygons Faster, Smudged Hexagon, Exercises

1.  Explore the effect of the `layers` argument in the `splotch()` system, and how it interacts with the `alpha` argument to `show_multipolygon()`

    ```{r}
    edge_length <- function(x1, y1, x2, y2) {
      sqrt((x1 - x2)^2 + (y1 - y2)^2)
    }

    edge_noise <- function(size) {
      runif(1, min = -size/2, max = size/2)
    }

    sample_edge_l <- function(polygon) {
      sample(length(polygon), 1, prob = map_dbl(polygon, ~ .x$seg_len))
    }

    insert_edge_l <- function(polygon, noise) {
      
      ind <- sample_edge_l(polygon)
      len <- polygon[[ind]]$seg_len
      
      last_x <- polygon[[ind]]$x
      last_y <- polygon[[ind]]$y
      
      next_x <- polygon[[ind + 1]]$x
      next_y <- polygon[[ind + 1]]$y
      
      new_x <- (last_x + next_x) / 2 + edge_noise(len * noise)
      new_y <- (last_y + next_y) / 2 + edge_noise(len * noise)
      
      new_point <- list(
        x = new_x,
        y = new_y,
        seg_len = edge_length(new_x, new_y, next_x, next_y)
      )
      
      polygon[[ind]]$seg_len <- edge_length(
        last_x, last_y, new_x, new_y
      )
      
      c(
        polygon[1:ind],
        list(new_point),
        polygon[-(1:ind)]
      )
    }

    grow_polygon_l <- function(polygon, iterations, noise, seed = NULL) {
      if(!is.null(seed)) set.seed(seed)
      for(i in 1:iterations) polygon <- insert_edge_l(polygon, noise)
      return(polygon)
    }

    grow_multipolygon_l <- function(base_shape, n, seed = NULL, ...) {
      if(!is.null(seed)) set.seed(seed)
      polygons <- list()
      for(i in 1:n) {
        polygons[[i]] <- grow_polygon_l(base_shape, ...) |>
          transpose() |>
          as_tibble() |>
          mutate(across(.fn = unlist))
      }
      polygons <- bind_rows(polygons, .id = "id")
      polygons
    }


    ```

    ```{r}
    show_multipolygon <- function(polygon, fill, alpha = .02, ...) {
      ggplot(polygon, aes(x, y, group = id)) +
        geom_polygon(colour = NA, alpha = alpha, fill = fill, ...) + 
        coord_equal() + 
        theme_void()
    }

    splotch <- function(seed, layers = 10) {
      set.seed(seed)
      square_l <- transpose(tibble(
        x = c(0, 1, 1, 0, 0),
        y = c(0, 0, 1, 1, 0),
        seg_len = c(1, 1, 1, 1, 0)
      ))
      square_l |> 
        grow_polygon_l(iterations = 10, noise = .5, seed = seed) |>
        grow_multipolygon_l(n = layers, iterations = 500, noise = .8, seed = seed) 
    }

    tic()
    dat <- splotch(seed = 1)
    splotch_11 <- splotch(seed = 8)

    splotch4 <- splotch(seed = 42)
    splotch10 <- splotch(seed = 66)
    splotch77 <- splotch(seed = 88)
    splotch99 <- splotch(seed = 99)
    toc()

    pic <- dat |> show_multipolygon(fill = "white", alpha = .2)
    ggsave(
      filename = here("output", "splotch.png"), 
      plot = pic,
      width = 2000,
      height = 2000,
      units = "px",
      dpi = 300,
      bg = "black"
    )
    ```

    ```{r}
    show_multipolygon(splotch4, fill ="#FF1493", alpha = 0.3)
    ```

    ```{r}
    show_multipolygon(splotch10, fill ="#1874CD", alpha = 0.3)
    ```

    ```{r}
    show_multipolygon(splotch77, fill ="#228B22", alpha = 0.3)
    ```

    ```{r}
    show_multipolygon(splotch99, fill ="#FF4500", alpha = 0.3)
    ```

2.  Create a modified version of the `smudged_hexagon()` system that creates a smudged triangle, or, if you're feeling more ambitious and want to read slightly further down the page to look for the code you need, a smudged heart shape!

    ```{r}
    edge_length <- function(x1, y1, x2, y2) {
      sqrt((x1 - x2)^2 + (y1 - y2)^2)
    }

    edge_noise <- function(size) {
      runif(1, min = -size/3, max = size/3)
    }

    sample_edge_l <- function(polygon) {
      sample(length(polygon), 2, prob = map_dbl(polygon, ~ .x$seg_len))
    }

    insert_edge_l <- function(polygon, noise) {
      
      ind <- sample_edge_l(polygon)
      len <- polygon[[ind]]$seg_len
      
      last_x <- polygon[[ind]]$x
      last_y <- polygon[[ind]]$y
      
      next_x <- polygon[[ind + 2]]$x
      next_y <- polygon[[ind + 2]]$y
      
      new_x <- (last_x + next_x) / 4 + edge_noise(len * noise)
      new_y <- (last_y + next_y) / 4 + edge_noise(len * noise)
      
      new_point <- list(
        x = new_x,
        y = new_y,
        seg_len = edge_length(new_x, new_y, next_x, next_y)
      )
      
      polygon[[ind]]$seg_len <- edge_length(
        last_x, last_y, new_x, new_y
      )
      
      c(
        polygon[1:ind],
        list(new_point),
        polygon[-(1:ind)]
      )
    }

    grow_polygon_l <- function(polygon, iterations, noise, seed = NULL) {
      if(!is.null(seed)) set.seed(seed)
      for(i in 1:iterations) polygon <- insert_edge_l(polygon, noise)
      return(polygon)
    }

    grow_multipolygon_l <- function(base_shape, n, seed = NULL, ...) {
      if(!is.null(seed)) set.seed(seed)
      polygons <- list()
      for(i in 1:n) {
        polygons[[i]] <- grow_polygon_l(base_shape, ...) |>
          transpose() |>
          as_tibble() |>
          mutate(across(.fn = unlist))
      }
      polygons <- bind_rows(polygons, .id = "id")
      polygons
    }

    show_multipolygon <- function(polygon, fill, alpha = .2, ...) {
      ggplot(polygon, aes(x, y, group = id)) +
        geom_polygon(colour = NA, alpha = alpha, fill = fill, ...) + 
        coord_equal() + 
        theme_void()
    }

    ```

    ```{r}

    edge_length <- function(x1, y1, x2, y2) {
      sqrt((x1 - x2)^2 + (y1 - y2)^2)
    }

    edge_noise <- function(size) {
      runif(1, min = -size/2, max = size/2)
    }

    sample_edge_l <- function(polygon) {
      sample(length(polygon), 1, prob = map_dbl(polygon, ~ .x$seg_len))
    }

    insert_edge_l <- function(polygon, noise) {
      
      ind <- sample_edge_l(polygon)
      len <- polygon[[ind]]$seg_len
      
      last_x <- polygon[[ind]]$x
      last_y <- polygon[[ind]]$y
      
      next_x <- polygon[[ind + 1]]$x
      next_y <- polygon[[ind + 1]]$y
      
      new_x <- (last_x + next_x) / 2 + edge_noise(len * noise)
      new_y <- (last_y + next_y) / 2 + edge_noise(len * noise)
      
      new_point <- list(
        x = new_x,
        y = new_y,
        seg_len = edge_length(new_x, new_y, next_x, next_y)
      )
      
      polygon[[ind]]$seg_len <- edge_length(
        last_x, last_y, new_x, new_y
      )
      
      c(
        polygon[1:ind],
        list(new_point),
        polygon[-(1:ind)]
      )
    }

    grow_polygon_l <- function(polygon, iterations, noise, seed = NULL) {
      if(!is.null(seed)) set.seed(seed)
      for(i in 1:iterations) polygon <- insert_edge_l(polygon, noise)
      return(polygon)
    }

    grow_multipolygon_l <- function(base_shape, n, seed = NULL, ...) {
      if(!is.null(seed)) set.seed(seed)
      polygons <- list()
      for(i in 1:n) {
        polygons[[i]] <- grow_polygon_l(base_shape, ...) |>
          transpose() |>
          as_tibble() |>
          mutate(across(.fn = unlist))
      }
      polygons <- bind_rows(polygons, .id = "id")
      polygons
    }

    show_multipolygon <- function(polygon, fill, alpha = .02, ...) {
      ggplot(polygon, aes(x, y, group = id)) +
        geom_polygon(colour = NA, alpha = alpha, fill = fill, ...) + 
        coord_equal() + 
        theme_void()
    }

    smudged_hexagon <- function(seed, noise1 = 0, noise2 = 2, noise3 = 0.5) {
      set.seed(seed)
      
      # define hexagonal base shape
      theta <- (0:6) * pi / 3
      hexagon <- tibble(
        x = sin(theta),
        y = cos(theta),
        seg_len = edge_length(x, y, lead(x), lead(y))
      )
      hexagon$seg_len[7] <- 0
      hexagon <- transpose(hexagon)
      base <- hexagon |> 
        grow_polygon_l(
          iterations = 60, 
          noise = noise1
        )
      
      # define intermediate-base-shapes in clusters
      polygons <- list()
      ijk <- 0
      for(i in 1:3) {
        base_i <- base |> 
          grow_polygon_l(
            iterations = 50, 
            noise = noise2
          )
        
        for(j in 1:3) {
          base_j <- base_i |> 
            grow_polygon_l(
              iterations = 50, 
              noise = noise2
            )
          
          # grow 10 polygons per intermediate-base
          for(k in 1:10) {
            ijk <- ijk + 1
            polygons[[ijk]] <- base_j |>
              grow_polygon_l(
                iterations = 500, 
                noise = noise3
              ) |>
              transpose() |>
              as_tibble() |>
              mutate(across(.fn = unlist))
          }
        }
      }
      
      # return as data frame
      bind_rows(polygons, .id = "id")
    }
    ```

    ```{r}
    tic()
    dat <- smudged_hexagon(seed = 88)
    pic <- dat |> show_multipolygon(fill = "#d4379005")
    ggsave(
      filename = here("output", "smudged-hexagon.png"), 
      plot = pic,
      width = 2000,
      height = 2000,
      units = "px",
      dpi = 300,
      bg = "#222222"
    )
    toc()

    show_multipolygon(dat, fill = "#C1FFC1")
    ```

3.  In the "layered" smudged hexagon example (the one with three hexagons of different colours), why did I include the calls to `mutate()` and `arrange()`? What would have happened without that code?

The mutate function being called to changes the data frame by adding a value for each hexagon and the arrange function orders the data frame by id columns. This arranges the hexagon by their unique IDs.

## Exercise 3

1.  

    ```{r}
    circle <- tibble(
      angle = seq(0, 2*pi, length.out = 50),
      x = cos(angle),
      y = sin(angle)
    )
    show_polygon(circle)

    normalise_radius <- function(x, min, max) {
      normalise(x, from = c(-0.5, 0.5), to = c(min, max))
    }

    perlin_blob <- function(n = 100, 
                            freq_init = 0.3,
                            octaves = 2, 
                            r_min = 0.5, 
                            r_max = 1) {
      tibble(
        angle = seq(0, 2*pi, length.out = n),
        x_base = cos(angle),
        y_base = sin(angle),
        radius = fracture(
          x = x_base, 
          y = y_base, 
          freq_init = freq_init,
          noise = gen_perlin, 
          fractal = fbm, 
          octaves = octaves
        ) |>
          normalise_radius(r_min, r_max),
        x = radius * x_base,
        y = radius * y_base
      )
    }


    ```

    ```{r}
    set.seed(4); perlin_blob() |> show_polygon(FALSE)
    set.seed(5); perlin_blob() |> show_polygon(FALSE)
    set.seed(6); perlin_blob() |> show_polygon(FALSE)

    ```

    ```{r}
    set.seed(1); perlin_blob(freq_init = .5) |> show_polygon(FALSE)
    set.seed(1); perlin_blob(freq_init = .3) |> show_polygon(FALSE)
    set.seed(1); perlin_blob(freq_init = .4) |> show_polygon(FALSE)


    ```

    ```{r}
    set.seed(1); 
    perlin_blob(
      n = 1000,
      freq_init = 10, 
      r_min = .95, 
      r_max = 1
    ) |> 
      show_polygon(FALSE)
    ```

2.  Try playing around with these two systems. See if you can reproduce the same "qualitative variations" with `perlin_heart()` that I showed above with `perlin_blob()`

3.  Explore the effect of modifying the arguments. It should be possible to produce some very wild looking shapes!

```{r}
show_polygon <- function(polygon, show_vertices = TRUE, ...) {
  
  pic <- ggplot(polygon, aes(x, y)) +
    geom_polygon(colour = "black", fill = NA, show.legend = FALSE, ...) + 
    coord_equal() + 
    theme_void()
  
  if(show_vertices == TRUE) {
    pic <- pic + geom_point(colour = "black", size = 2)
  }
  return(pic)
}

heart_x <- function(angle) {
  x <- (16 * sin(angle) ^ 3) / 17
  return(x - mean(x))
}

heart_y <- function(angle) {
  y <- (13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) -
          cos(4 * angle)) / 17
  return(y - mean(y))
}

normalise_radius <- function(x, min, max) {
  normalise(x, from = c(-0.5, 0.5), to = c(min, max))
}

perlin_heart <- function(n = 100, 
                         freq_init = 0.3,
                         octaves = 2, 
                         r_min = 0.5, 
                         r_max = 1,
                         x_shift = 0,
                         y_shift = 0,
                         id = NA,
                         seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  tibble(
    angle = seq(0, 2*pi, length.out = n),
    x_base = cos(angle),
    y_base = sin(angle),
    radius = fracture(
      x = x_base, 
      y = y_base, 
      freq_init = freq_init,
      noise = gen_perlin, 
      fractal = fbm, 
      octaves = octaves
    ) |>
      normalise_radius(r_min, r_max),
    x = radius * heart_x(angle) + x_shift,
    y = radius * heart_y(angle) + y_shift,
    id = id
  )
}

set.seed(3); 
pic <- perlin_heart(freq_init = .4) |> show_polygon(FALSE)
plot(pic)
```

```{r}
perlin_heart(seed = 2) |> show_polygon(FALSE)
```

```{r}
perlin_heart(seed = 4) |> show_polygon(FALSE)
```

## Exercise 4

Code for this system is included as the `perlin-heart-grid.R` script. To check that you understand it, try modifying it in the following ways:

1.  Only show 50% of the hearts

2.  Add a small amount of random noise to the position of each heart

3.  Give all the hearts the "rough edged biscuit" look

```{r}
sample_canva <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]]
}

show_polygon <- function(polygon, show_vertices = TRUE, ...) {
  
  pic <- ggplot(polygon, aes(x, y)) +
    geom_polygon(colour = "black", fill = NA, show.legend = FALSE, ...) + 
    coord_equal() + 
    theme_void()
  
  if(show_vertices == TRUE) {
    pic <- pic + geom_point(colour = "black", size = 2)
  }
  return(pic)
}

heart_x <- function(angle) {
  x <- (16 * sin(angle) ^ 3) / 17
  return(x - mean(x))
}

heart_y <- function(angle) {
  y <- (13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) -
          cos(4 * angle)) / 17
  return(y - mean(y))
}

normalise_radius <- function(x, min, max) {
  normalise(x, from = c(-0.5, 0.5), to = c(min, max))
}

perlin_heart <- function(n = 100, 
                         freq_init = 0.3,
                         octaves = 2, 
                         r_min = 0.5, 
                         r_max = 1,
                         x_shift = 0,
                         y_shift = 0,
                         id = NA,
                         seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  tibble(
    angle = seq(0, 2*pi, length.out = n),
    x_base = cos(angle),
    y_base = sin(angle),
    radius = fracture(
      x = x_base, 
      y = y_base, 
      freq_init = freq_init,
      noise = gen_perlin, 
      fractal = fbm, 
      octaves = octaves
    ) |>
      normalise_radius(r_min, r_max),
    x = radius * heart_x(angle) + x_shift,
    y = radius * heart_y(angle) + y_shift,
    id = id
  )
}

perlin_heart_grid <- function(nx = 10, ny = 6, seed = NULL) {
  if(!is.null(seed)) set.seed(seed)

```

50% of hearts

```{r}
perlin_heart_grid <- function(nx = 5, ny = 3, seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  
  heart_settings <- expand_grid(
    r_min = .3, 
    r_max = .4, 
    x_shift = 1:nx, 
    y_shift = 1:ny
  ) |>
    mutate(id = row_number()) 
  
  heart_data <-  pmap_dfr(heart_settings, perlin_heart)
  
  heart_data |>
    ggplot(aes(x, y, group = id, fill = sample(id))) +
    geom_polygon(size = 0, show.legend = FALSE) +
    theme_void() +
    scale_fill_gradientn(colours = sample_canva(seed)) +
    coord_equal(xlim = c(0, nx + 1), ylim = c(0, ny + 1))
}

pic <- perlin_heart_grid(seed = 451)
plot(pic)
```

adding noise

```{r}
perlin_heart_grid2 <- function(nx = 10, ny = 6, seed = NULL, noise = NULL) {
  if(!is.null(seed)) set.seed(seed)
  
  heart_settings <- expand_grid(
    r_min = .3, 
    r_max = .4, 
    x_shift = 1:nx, 
    y_shift = 1:ny
  ) |>
    mutate(id = row_number()) 
  
  heart_data <-  pmap_dfr(heart_settings, perlin_heart)
  
  heart_data |>
    ggplot(aes(x, y, group = id, fill = sample(id))) +
    geom_polygon(size = 0, show.legend = FALSE) +
    theme_void() +
    scale_fill_gradientn(colours = sample_canva(seed)) +
    coord_equal(xlim = c(0, nx + .5), ylim = c(0, ny + .5))
}

perlin_heart_grid2(seed = 451, noise = 30)
```

rough edged biscuit

```{r}
perlin_heart_grid3 <- function(nx = 2, ny = 1, seed = NULL, noise = NULL) {
  if(!is.null(seed)) set.seed(seed)
  
  heart_settings <- expand_grid(
     n = 5000,
    freq_init = 100,
    r_min = .8, 
    r_max = .1
  ) |>
    mutate(id = row_number()) 
  
  heart_data <-  pmap_dfr(heart_settings, perlin_heart)
  
  heart_data |>
    ggplot(aes(x, y, group = id, fill = sample(id))) +
    geom_polygon(size = 0, show.legend = FALSE) +
    theme_void() +
    scale_fill_gradientn(colours = sample_canva(seed)) +
    coord_equal(xlim = c(0, nx + .5), ylim = c(0, ny + .5))
}

perlin_heart_grid2(seed = 100, noise = 0)
```

### Exercise 5

Code for this system is included as the `perlin-heart-grid-2.R` script. Can you modify it so that each heart is plotted in a single colour rather than in the banded pattern? With different hearts having different colours?

```{r}
sample_canva <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 3)[[1]]
}

show_polygon <- function(polygon, show_vertices = TRUE, ...) {
  
  pic <- ggplot(polygon, aes(x, y)) +
    geom_polygon(colour = "black", fill = NA, show.legend = FALSE, ...) + 
    coord_equal() + 
    theme_void()
  
  if(show_vertices == TRUE) {
    pic <- pic + geom_point(colour = "black", size = 2)
  }
  return(pic)
}

heart_x <- function(angle) {
  x <- (14 * sin(angle) ^ 3) / 17
  return(x - mean(x))
}

heart_y <- function(angle) {
  y <- (12 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) -
          cos(4 * angle)) / 17
  return(y - mean(y))
}

normalise_radius <- function(x, min, max) {
  normalise(x, from = c(-0.5, 0.5), to = c(min, max))
}

perlin_heart2 <- function(n = 100, 
                          freq_init = 0.3,
                          octaves = 2, 
                          r_min = 0.5, 
                          r_max = 1,
                          w_min = 0,
                          w_max = 4,
                          rot = 0,
                          x_shift = 0,
                          y_shift = 0,
                          id = NA,
                          seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  tibble(
    angle = seq(0, 2*pi, length.out = n),
    
    radius = fracture(
      x = cos(angle), 
      y = sin(angle), 
      freq_init = freq_init,
      noise = gen_perlin, 
      fractal = fbm, 
      octaves = octaves
    ) |>
      normalise_radius(r_min, r_max),
    
    x = radius * heart_x(angle) + x_shift,
    y = radius * heart_y(angle) + y_shift,
    
    width = fracture(
      x = cos(angle + rot), 
      y = sin(angle + rot), 
      freq_init = freq_init,
      noise = gen_perlin, 
      fractal = fbm, 
      octaves = octaves
    ) |>
      normalise(to = c(w_min, w_max)),
    
    id = id
  )
}

perlin_heart_grid2 <- function(nx = 4, ny = 2, seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  
  heart_settings <- expand_grid(
    r_min = .3, 
    r_max = .4, 
    w_min = .01,
    w_max = 6,
    x_shift = 1:nx, 
    y_shift = 1:ny
  ) |>
    mutate(
      n = 200,
      x_shift = x_shift + runif(n(), -.1, .1),
      y_shift = y_shift + runif(n(), -.1, .1),
      rot = runif(n(), -.1, .1),
      id = row_number()
    ) 
  
  heart_data <-  pmap_dfr(heart_settings, perlin_heart2)
  
  heart_data |>
    ggplot(aes(x, y, group = id, colour = sample(id), size = width)) +
    geom_path(show.legend = FALSE) +
    theme_void() +
    scale_size_identity() +
    scale_colour_gradientn(colours = sample_canva(seed)) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    coord_fixed(xlim = c(0, nx + 1), ylim = c(0, ny + 1))
}

pic <- perlin_heart_grid2(seed = 666)
plot(pic)
```

## Exercise 6

Code for this system is included in the `perlin-heart-animated.R` script. Personally I just find this one fun to play with, so instead of setting an exercise I'll let you take a look!

```{r}

sample_canva <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]]
}

show_polygon <- function(polygon, show_vertices = TRUE, ...) {
  
  pic <- ggplot(polygon, aes(x, y)) +
    geom_polygon(colour = "black", fill = NA, show.legend = FALSE, ...) + 
    coord_equal() + 
    theme_void()
  
  if(show_vertices == TRUE) {
    pic <- pic + geom_point(colour = "black", size = 2)
  }
  return(pic)
}

heart_x <- function(angle) {
  x <- (16 * sin(angle) ^ 3) / 17
  return(x - mean(x))
}

heart_y <- function(angle) {
  y <- (13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) -
          cos(4 * angle)) / 17
  return(y - mean(y))
}

normalise_radius <- function(x, min, max) {
  normalise(x, from = c(-0.5, 0.5), to = c(min, max))
}

perlin_heart2 <- function(n = 100, 
                          freq_init = 0.3,
                          octaves = 2, 
                          r_min = 0.5, 
                          r_max = 1,
                          w_min = 0,
                          w_max = 4,
                          rot = 0,
                          x_shift = 0,
                          y_shift = 0,
                          id = NA,
                          seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  tibble(
    angle = seq(0, 2*pi, length.out = n),
    
    radius = fracture(
      x = cos(angle), 
      y = sin(angle), 
      freq_init = freq_init,
      noise = gen_perlin, 
      fractal = fbm, 
      octaves = octaves
    ) |>
      normalise_radius(r_min, r_max),
    
    x = radius * heart_x(angle) + x_shift,
    y = radius * heart_y(angle) + y_shift,
    
    width = fracture(
      x = cos(angle + rot), 
      y = sin(angle + rot), 
      freq_init = freq_init,
      noise = gen_perlin, 
      fractal = fbm, 
      octaves = octaves
    ) |>
      normalise(to = c(w_min, w_max)),
    
    id = id
  )
}

perlin_heart_data <- function(nhearts = 10, scatter = .05, seed = NULL) {
  
  if(!is.null(seed)) set.seed(seed)
  
  palette <- sample_canva(seed) |>
    (\(x) colorRampPalette(x)(nhearts))()
  
  heart_settings <- tibble(
    id = 1:nhearts,
    n = 500,
    r_min = .35, 
    r_max = .4,
    w_min = -10, 
    w_max = 10,
    x_shift = runif(nhearts, -scatter/2, scatter/2),
    y_shift = runif(nhearts, -scatter/2, scatter/2),
    rot = runif(nhearts, -pi, pi)
  )
  
  heart_settings |>
    pmap_dfr(perlin_heart2) |>
    group_by(id) |>
    mutate(
      shade = sample(palette, 1),
      width = abs(width)
    )
}

generate_one_frame <- function(dat) {
  
  pic <- dat |>
    ggplot(aes(x, y, group = id, size = width, colour = shade)) +
    geom_path(show.legend = FALSE) +
    theme_void() +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    scale_colour_identity() +
    scale_size_identity() +
    coord_fixed(xlim = c(-.6, .6), ylim = c(-.6, .6))
  
  print(pic)
}

rotate_vector <- function(x, percent) {
  
  len <- length(x)
  ind <- ceiling(len * percent)
  if(ind == 0) return(x)
  if(ind == len) return(x)
  c(x[(ind+1):len], x[1:ind])
}

generate_all_frames <- function(dat, nframes = 100) {
  
  for(frame in 1:nframes) {
    dat |>
      group_by(id) |>
      mutate(width = width |> rotate_vector(frame / nframes)) |>
      generate_one_frame()
  }
}

animated_perlin_heart <- function(seed, ...) {
  
  gif_file <- paste0("animated-perlin-heart-", seed, ".gif")
  save_gif(
    expr = perlin_heart_data(seed = seed, ...) |> generate_all_frames(),
    gif_file = here("output", gif_file),
    height = 1000,
    width = 1000,
    delay = .1,
    progress = TRUE,
    bg = "#222222"
  )
  invisible(NULL)
}

tic()
animated_perlin_heart(seed = 99)
toc()
```

## Exercise 7

```{r}
library(dplyr)
library(tibble)
library(ggplot2)
library(here)
library(e1071)

smooth_loess <- function(x, span) {
  n <- length(x)
  dat <- tibble(time = 1:n, walk = x)
  mod <- loess(walk ~ time, dat, span = span)
  predict(mod, tibble(time = 1:n))
}

smooth_path <- function(n = 1000, smoothing = .4, seed = NULL) { 
  if(!is.null(seed)) set.seed(seed)
  tibble(
    x = smooth_loess(rbridge(1, n), span = smoothing),
    y = smooth_loess(rbridge(1, n), span = smoothing),
    stroke = 1
  )
}

perturb <- function(path, noise = .03, span = .1) {
  path |> 
    group_by(stroke) |>
    mutate(
      x = x + rnorm(n(), 0, noise),
      y = y + rnorm(n(), 0, noise),
      x = smooth_loess(x, span),
      y = smooth_loess(y, span),
      alpha = runif(n()) > .5,
      size = runif(n(), 0, .2)
    )
}

brush <- function(path, bristles = 100, seed = 1, ...) {
  set.seed(seed)
  dat <- list()
  for(i in 1:bristles) {
    dat[[i]] <- perturb(path, ...)
  }
  return(bind_rows(dat, .id = "id"))
}

stroke <- function(dat, geom = geom_path, colour = "coral", ...) {
  dat |>  
    ggplot(aes(
      x = x, 
      y = y, 
      alpha = alpha, 
      size = size, 
      group = paste0(stroke, id)
    )) + 
    geom(
      colour = colour, 
      show.legend = FALSE,
      ...
    ) + 
    coord_equal() +
    scale_alpha_identity() +
    scale_size_identity() +
    theme_void() + 
    theme(plot.background = element_rect(
      fill = "blue", 
      colour = "red"
    ))
}

path <- smooth_path(seed = 400)
pic <- path |> brush() |> stroke()
plot(pic)
```

## Pixel Filters

```{r}
library(dplyr)
library(tibble)
library(ggplot2)
library(ggforce)
library(ggfx)
library(flametree)
library(ambient)
```

## Exercise 1

A script containing this code is included as the `flametree-example.R` script.

```{r}
#changed seed size, changed time, changed angle, changed stroke
tree <- flametree_grow(
  seed = 2, 
  time = 10, 
  angle = c(-11, 10, 20)
)

leaf <- tree |> filter(id_leaf == TRUE)

base <- ggplot() + 
  scale_size_identity() + 
  theme_void() + 
  coord_equal()

leaves <- geom_point(
  mapping = aes(coord_x, coord_y),
  data = leaf, 
  size = 2, 
  stroke = 0, 
  colour = "#483D8B"
)

trunk <- geom_bezier(
  mapping = aes(coord_x, coord_y, group = id_pathtree, size = seg_wid),
  data = tree, 
  lineend = "round", 
  colour = "#8B795E",
  show.legend = FALSE
)

plot(base + trunk + leaves)
```

## Exercise 2

A script containing this code is included as the `ggfx-glow.R` file

```{r}
#changing seed, time, angles, color schemes
library(dplyr)
library(tibble)
library(ggplot2)
library(ggforce)
library(flametree)
library(ggfx)

tree <- flametree_grow(
  seed = 2, 
  time = 20, 
  angle = c(-10, 10, 20)
)

leaf <- tree |> filter(id_leaf == TRUE)

base <- ggplot() + 
  scale_size_identity() + 
  theme_void() + 
  coord_equal()

leaves <- geom_point(
  mapping = aes(coord_x, coord_y),
  data = leaf, 
  size = 1.7, 
  stroke = 0, 
  colour = "#8470FF"
)

trunk <- geom_bezier(
  mapping = aes(coord_x, coord_y, group = id_pathtree, size = seg_wid),
  data = tree, 
  lineend = "round", 
  colour = "#32CD32",
  show.legend = FALSE
)

plot(
  base +   
    trunk + 
    with_outer_glow(leaves, colour = "#FF00FF", sigma = 6, expand = 3)
)
```

## Exercise 3

A script containing this code is included as the `ggfx-dither.R` file

```{r}
set.seed(1)
polar <- tibble(
  arc_start = runif(300),
  arc_end = arc_start + runif(300, min = -.2, max = .2),
  radius = runif(300),
  shade = runif(300), 
  size = runif(300)
)

base <- ggplot(
  data = polar, 
  mapping = aes(
    x = arc_start, 
    y = radius,
    xend = arc_end, 
    yend = radius, 
    colour = shade, 
    size = size
  )
) + 
  coord_polar(clip = "off") +
  scale_y_continuous(limits = c(0, 1), oob = scales::oob_keep) +
  scale_x_continuous(limits = c(0, 1), oob = scales::oob_keep) + 
  scale_colour_viridis_c(option = "magma") +
  guides(colour = guide_none(), size = guide_none()) + 
  scale_size(range = c(0, 15)) + 
  theme_void() +
  theme(panel.background = element_rect(fill = "aquamarine"))

plot(base + with_halftone_dither(geom_segment()))

```

## Exercise 4

A script containing this code is included as the `ggfx-mask.R` file

```{r}
texture <- geom_raster(
  mapping = aes(x, y, fill = paint),
  data = long_grid(
    x = seq(from = -1, to = 1, length.out = 1000),
    y = seq(from = -1, to = 1, length.out = 1000)
  ) |> 
    mutate(
      lf_noise = gen_simplex(x, y, frequency = 4, seed = 1234),
      mf_noise = gen_simplex(x, y, frequency = 40, seed = 1234),
      hf_noise = gen_simplex(x, y, frequency = 200, seed = 1234),
      paint = lf_noise + mf_noise + hf_noise
    )
)

hex <- tibble(x = sin((0:6)/6 * 2 * pi), y = cos((0:6)/6 * 2 * pi))
mask <- geom_polygon(aes(x, y), hex, fill = "white")

base <- ggplot() + 
  theme_void() +
  coord_equal() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_gradientn(
    colours = c("aquamarine1","purple2"), 
    guide = guide_none()
  )

border <- geom_path(aes(x, y), hex, colour = "white", size = 16)

text <- geom_text(
  mapping = aes(x, y, label = text), 
  dat = tibble(x = 0, y = 0, text = "ART"), 
  size = 30,
  colour = "white", 
  fontface = "bold"
) 

plot(
  base + 
    as_group(texture, text, border, id = "content") +
    as_reference(mask, id = "mask") + 
    with_mask("content", "mask")
)
```

## Exercise 5

A script containing this code is included as the `ggfx-displace.R` file

```{r}

polygon_layer <- function(x, y, fill = "black", alpha = .5) {
  geom_polygon(aes(x, y), fill = fill, alpha = alpha)
}
poly1 <- polygon_layer(x = c(1, 0, 0), y = c(0, 0, 1))
poly2 <- polygon_layer(x = c(0, 1, 1), y = c(0, 0, 1))
poly3 <- polygon_layer(x = c(.3, 1, 1), y = c(0, 0, .7))
poly4 <- polygon_layer(x = c(0, 0, .7), y = c(.3, 1, 1))

base <- ggplot() + 
  coord_equal(xlim = c(0, 1), ylim = c(0, 1)) + 
  theme_void() + 
  theme(panel.background = element_rect(fill = "seagreen"))

text <- geom_text(
  mapping = aes(0.5, 0.5, label = "YAY"), 
  size = 20, 
  colour = "white", 
  fontface = "bold"
)

plot(
  base + 
    as_group(poly1, poly2, poly3, poly4, id = "polygons", include = TRUE) +
    as_reference("polygons", id = "displacement_map") + 
    with_displacement(
      text,
      x_map = ch_alpha("displacement_map"),
      y_map = ch_alpha("displacement_map"), 
      x_scale = 150,
      y_scale = -150
    )
)
```

## Exercise 6

A script containing this code is included as the `ggfx-blend.R` file

```{r}

tree <- flametree_grow(
  seed = 2, 
  time = 15, 
  angle = c(-15, 15, 30))

leaf <- tree |> filter(id_leaf == TRUE)

leaves <- geom_point(
  data = leaf, 
  mapping = aes(coord_x, coord_y, colour = seg_col),
  colour = "seagreen",
  size = 4, 
  stroke = 0
)

trunk <- geom_bezier(
  data = tree,
  mapping = aes(
    x = coord_x, 
    y = coord_y, 
    size = seg_wid,
    group = id_pathtree
  ),
  colour = "brown4",
  lineend = "round"
)

polygon_layer <- function(x, y, fill = "white", alpha = .5) {
  geom_polygon(aes(x, y), fill = fill, alpha = alpha)
}

triangle <- polygon_layer(
  x = c(-4, 2, 2), 
  y = c(0, 0, 6), 
  fill = "lightgreen",
  alpha = 1
)

base <- ggplot() + 
  theme_void() +
  theme(panel.background = element_rect(
    fill = "slategrey", colour = "aquamarine"
  )) + 
  coord_equal(xlim = c(-3, 1), ylim = c(1, 5)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_size_identity(guide = guide_none())

plot(
  base +
    as_group(trunk, leaves, id = "tree") + 
    with_blend(triangle, "tree", blend_type = "xor")
)
```
